#pragma once
#include "pch.h"
#include "Regular_expression.cpp"
#include "SintaxTree.cpp"
#include "DeterminedFinalAutomat.cpp"
#include "NondeterminedFinalAutomata.cpp"
using namespace rgx;
TEST(OperatorsTest, Scrining) {
	Regular_expression* r;
		ASSERT_NO_THROW(r = new Regular_expression("&&"));
		ASSERT_TRUE(checkString("&", *r));
		ASSERT_FALSE(checkString("&&", *r));
		ASSERT_FALSE(checkString("a", *r));
		delete r;
		ASSERT_NO_THROW(r = new Regular_expression("&a"));
		ASSERT_TRUE(checkString("a", *r));
		ASSERT_FALSE(checkString("&a", *r));
		ASSERT_FALSE(checkString("a&", *r));
		delete r;
		ASSERT_NO_THROW(r = new Regular_expression("a&a"));
		ASSERT_TRUE(checkString("aa", *r));
		ASSERT_FALSE(checkString("a&a", *r));
		ASSERT_FALSE(checkString("a", *r));
		delete r;
		ASSERT_NO_THROW(r = new Regular_expression("&&&&"));
		ASSERT_TRUE(checkString("&&", *r));
		ASSERT_FALSE(checkString("&&&", *r));
		ASSERT_FALSE(checkString("&", *r));
		ASSERT_FALSE(checkString("&&&&", *r));
		delete r;
		ASSERT_NO_THROW(r = new Regular_expression("a&?b"));
		ASSERT_TRUE(checkString("a?b", *r));
		ASSERT_FALSE(checkString("ab", *r));
		ASSERT_FALSE(checkString("a", *r));
		ASSERT_FALSE(checkString("a&b", *r));
		delete r;
		ASSERT_THROW(r = new Regular_expression("&"), SintaxTree_Exception);
		ASSERT_THROW(r = new Regular_expression("a&"), SintaxTree_Exception);
}
TEST(OperatorsTest, Positive_Closure) {
	Regular_expression* r;
	ASSERT_NO_THROW(r = new Regular_expression("a+"));
	ASSERT_TRUE(checkString("a", *r));
	ASSERT_TRUE(checkString("aaaaaaaa", *r));
	ASSERT_FALSE(checkString("", *r));
	ASSERT_FALSE(checkString("aaaaab", *r));
	ASSERT_FALSE(checkString("b", *r));
	delete r;
	ASSERT_NO_THROW(r = new Regular_expression("ab+"));
	ASSERT_TRUE(checkString("ab", *r));
	ASSERT_TRUE(checkString("abbbb", *r));
	ASSERT_FALSE(checkString("a", *r));
	ASSERT_FALSE(checkString("aaaaab", *r));
	ASSERT_FALSE(checkString("bbbbb", *r));
	delete r;
	ASSERT_NO_THROW(r = new Regular_expression("b+a"));
	ASSERT_TRUE(checkString("ba", *r));
	ASSERT_TRUE(checkString("bbbbba", *r));
	ASSERT_FALSE(checkString("b", *r));
	ASSERT_FALSE(checkString("a", *r));
	ASSERT_FALSE(checkString("b+a", *r));
	delete r;
	ASSERT_NO_THROW(r = new Regular_expression("b++"));
	ASSERT_TRUE(checkString("b", *r));
	ASSERT_TRUE(checkString("bbbbb", *r));
	ASSERT_FALSE(checkString("", *r));
	ASSERT_FALSE(checkString("a", *r));
	ASSERT_FALSE(checkString("b+", *r));
	delete r;
	ASSERT_NO_THROW(r = new Regular_expression("(ab)+"));
	ASSERT_TRUE(checkString("ab", *r));
	ASSERT_TRUE(checkString("ababababab", *r));
	ASSERT_FALSE(checkString("", *r));
	ASSERT_FALSE(checkString("a", *r));
	ASSERT_FALSE(checkString("b", *r));
	ASSERT_FALSE(checkString("abbbbb", *r));
	ASSERT_FALSE(checkString("aaaabbbbb", *r));
	delete r;
	ASSERT_THROW(r = new Regular_expression("+"), SintaxTree_Exception);
	ASSERT_THROW(r = new Regular_expression("+a"), SintaxTree_Exception);
}
TEST(OperatorsTest, Optional) {
	Regular_expression* r;
	ASSERT_NO_THROW(r = new Regular_expression("a?"));
	ASSERT_TRUE(checkString("a", *r));
	ASSERT_TRUE(checkString("", *r));
	ASSERT_FALSE(checkString("a?", *r));
	ASSERT_FALSE(checkString("aa", *r));
	ASSERT_FALSE(checkString("b", *r));
	delete r;
	ASSERT_NO_THROW(r = new Regular_expression("ab?"));
	ASSERT_TRUE(checkString("ab", *r));
	ASSERT_TRUE(checkString("a", *r));
	ASSERT_FALSE(checkString("", *r));
	ASSERT_FALSE(checkString("b", *r));
	ASSERT_FALSE(checkString("ab?", *r));
	delete r;
	ASSERT_NO_THROW(r = new Regular_expression("b?a"));
	ASSERT_TRUE(checkString("ba", *r));
	ASSERT_TRUE(checkString("a", *r));
	ASSERT_FALSE(checkString("b", *r));
	ASSERT_FALSE(checkString("", *r));
	ASSERT_FALSE(checkString("b?a", *r));
	delete r;
	ASSERT_NO_THROW(r = new Regular_expression("b??"));
	ASSERT_TRUE(checkString("b", *r));
	ASSERT_TRUE(checkString("", *r));
	ASSERT_FALSE(checkString("bb", *r));
	ASSERT_FALSE(checkString("ab", *r));
	ASSERT_FALSE(checkString("b?", *r));
	delete r;
	ASSERT_NO_THROW(r = new Regular_expression("(ab)?"));
	ASSERT_TRUE(checkString("ab", *r));
	ASSERT_TRUE(checkString("", *r));
	ASSERT_FALSE(checkString("a", *r));
	ASSERT_FALSE(checkString("b", *r));
	ASSERT_FALSE(checkString("ab?", *r));
	delete r;
	ASSERT_THROW(r = new Regular_expression("?"), SintaxTree_Exception);
	ASSERT_THROW(r = new Regular_expression("?a"), SintaxTree_Exception);
}
TEST(OperatorsTest, Repeat) {
	Regular_expression* r;
	ASSERT_NO_THROW(r = new Regular_expression("a{1,4}"));
	ASSERT_TRUE(checkString("a", *r));
	ASSERT_TRUE(checkString("aa", *r));
	ASSERT_TRUE(checkString("aaaa", *r));
	ASSERT_TRUE(checkString("aaa", *r));
	ASSERT_FALSE(checkString("", *r));
	ASSERT_FALSE(checkString("aaaaa", *r));
	delete r;
	ASSERT_NO_THROW(r = new Regular_expression("a{0,2}"));
	ASSERT_TRUE(checkString("", *r));
	ASSERT_TRUE(checkString("a", *r));
	ASSERT_TRUE(checkString("aa", *r));
	ASSERT_FALSE(checkString("aaa", *r));
	delete r;
	ASSERT_NO_THROW(r = new Regular_expression("a{2,}"));
	ASSERT_TRUE(checkString("aa", *r));
	ASSERT_TRUE(checkString("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", *r));
	ASSERT_FALSE(checkString("a", *r));
	ASSERT_FALSE(checkString("", *r));
	delete r;
	ASSERT_NO_THROW(r = new Regular_expression("a{,}"));
	ASSERT_TRUE(checkString("a", *r));
	ASSERT_TRUE(checkString("", *r));
	ASSERT_TRUE(checkString("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", *r));
	delete r;
	ASSERT_NO_THROW(r = new Regular_expression("(ab){2,3}"));
	ASSERT_TRUE(checkString("abab", *r));
	ASSERT_TRUE(checkString("ababab", *r));
	ASSERT_FALSE(checkString("ab", *r));
	ASSERT_FALSE(checkString("abababab", *r));
	ASSERT_FALSE(checkString("abb", *r));
	delete r;
	ASSERT_NO_THROW(r = new Regular_expression("(ab){0,0}"));
	ASSERT_TRUE(checkString("", *r));
	ASSERT_FALSE(checkString("ab", *r));
	ASSERT_FALSE(checkString("abababab", *r));
	ASSERT_FALSE(checkString("abb", *r));
	delete r;
	ASSERT_THROW(r = new Regular_expression("{0,2}"), SintaxTree_Exception);
	ASSERT_THROW(r = new Regular_expression("{0,2}a"), SintaxTree_Exception);
	ASSERT_THROW(r = new Regular_expression("a{2,1}"), SintaxTree_Exception);
}
TEST(OperatorsTest, AnyChar) {
	Regular_expression* r;
	ASSERT_NO_THROW(r = new Regular_expression("."));
	ASSERT_TRUE(checkString("a", *r));
	ASSERT_TRUE(checkString("b", *r));
	ASSERT_TRUE(checkString(".", *r));
	ASSERT_TRUE(checkString("?", *r));
	ASSERT_FALSE(checkString("aa", *r));
	ASSERT_FALSE(checkString("", *r));
	delete r;
	ASSERT_NO_THROW(r = new Regular_expression("a."));
	ASSERT_TRUE(checkString("ab", *r));
	ASSERT_TRUE(checkString("a.", *r));
	ASSERT_FALSE(checkString("", *r));
	ASSERT_FALSE(checkString("a", *r));
	delete r;
	ASSERT_NO_THROW(r = new Regular_expression(".."));
	ASSERT_TRUE(checkString("ba", *r));
	ASSERT_TRUE(checkString("ab", *r));
	ASSERT_FALSE(checkString("b", *r));
	ASSERT_FALSE(checkString("", *r));
	ASSERT_FALSE(checkString("b?a", *r));
	delete r;
	ASSERT_NO_THROW(r = new Regular_expression(".+"));
	ASSERT_TRUE(checkString("aaaaaaa", *r));
	ASSERT_TRUE(checkString("abcrddf", *r));
	ASSERT_FALSE(checkString("", *r));
	delete r;
}
TEST(OperatorsTest, Concat) {
	Regular_expression* r;
	ASSERT_NO_THROW(r = new Regular_expression("ab"));
	ASSERT_TRUE(checkString("ab", *r));
	ASSERT_FALSE(checkString("a", *r));
	ASSERT_FALSE(checkString("aa", *r));
	ASSERT_FALSE(checkString("ba", *r));
	delete r;
	ASSERT_NO_THROW(r = new Regular_expression("abc"));
	ASSERT_TRUE(checkString("abc", *r));
	ASSERT_FALSE(checkString("ab", *r));
	ASSERT_FALSE(checkString("", *r));
	ASSERT_FALSE(checkString("bc", *r));
	ASSERT_FALSE(checkString("ac", *r));
	delete r;
	ASSERT_NO_THROW(r = new Regular_expression("a"));
	ASSERT_TRUE(checkString("a", *r));
	ASSERT_FALSE(checkString("b", *r));
	ASSERT_FALSE(checkString("", *r));
	ASSERT_FALSE(checkString("aa", *r));
	delete r;
}
TEST(OperatorsTest,Or) {
	Regular_expression* r;
	ASSERT_NO_THROW(r = new Regular_expression("a|b"));
	ASSERT_TRUE(checkString("a", *r));
	ASSERT_TRUE(checkString("b", *r));
	ASSERT_FALSE(checkString("ab", *r));
	ASSERT_FALSE(checkString("", *r));
	delete r;
	ASSERT_NO_THROW(r = new Regular_expression("ab|bc"));
	ASSERT_TRUE(checkString("ab", *r));
	ASSERT_TRUE(checkString("bc", *r));
	ASSERT_FALSE(checkString("abbc", *r));
	ASSERT_FALSE(checkString("abc", *r));
	ASSERT_FALSE(checkString("", *r));
	delete r;
	ASSERT_NO_THROW(r = new Regular_expression("a|bcde"));
	ASSERT_TRUE(checkString("a", *r));
	ASSERT_TRUE(checkString("bcde", *r));
	ASSERT_FALSE(checkString("", *r));
	ASSERT_FALSE(checkString("abcde", *r));
	delete r;
	ASSERT_NO_THROW(r = new Regular_expression("abd|abc"));
	ASSERT_TRUE(checkString("abd", *r));
	ASSERT_TRUE(checkString("abc", *r));
	ASSERT_FALSE(checkString("abf", *r));
	ASSERT_FALSE(checkString("", *r));
	delete r;
	ASSERT_NO_THROW(r = new Regular_expression("(ab|bc)d"));
	ASSERT_TRUE(checkString("abd", *r));
	ASSERT_TRUE(checkString("bcd", *r));
	ASSERT_FALSE(checkString("d", *r));
	delete r;
	ASSERT_NO_THROW(r = new Regular_expression("ab|bc|cd"));
	ASSERT_TRUE(checkString("ab", *r));
	ASSERT_TRUE(checkString("bc", *r));
	ASSERT_TRUE(checkString("cd", *r));
	ASSERT_FALSE(checkString("ad", *r));
	delete r;
	ASSERT_NO_THROW(r = new Regular_expression("(ab|bc|cd)e"));
	ASSERT_TRUE(checkString("abe", *r));
	ASSERT_TRUE(checkString("bce", *r));
	ASSERT_TRUE(checkString("cde", *r));
	ASSERT_FALSE(checkString("ade", *r));
	delete r;
	ASSERT_THROW(r = new Regular_expression("|"), SintaxTree_Exception);
	ASSERT_THROW(r = new Regular_expression("|a"), SintaxTree_Exception);
	ASSERT_THROW(r = new Regular_expression("a|"), SintaxTree_Exception);
	ASSERT_THROW(r = new Regular_expression("a|+"), SintaxTree_Exception);
}
TEST(OperatorsTest, CaptureGroup) {
	Regular_expression* r;
	ASSERT_NO_THROW(r = new Regular_expression("(<a>a)"));
	RgxResult res;
	ASSERT_TRUE(checkString("a", *r, res));
	ASSERT_STREQ("a", res.namedGroups.value()[0]["a"].c_str());
	ASSERT_FALSE(checkString("", *r,res));
	ASSERT_FALSE(checkString("<a>a", *r,res));
	delete r;
	ASSERT_NO_THROW(r = new Regular_expression("(<a>a|b)"));
	ASSERT_TRUE(checkString("a", *r,res));
	ASSERT_STREQ("a", res.namedGroups.value()[0]["a"].c_str());
	ASSERT_TRUE(checkString("b", *r,res));
	ASSERT_STREQ("b", res.namedGroups.value()[0]["a"].c_str());
	ASSERT_FALSE(checkString("ab", *r,res));
	ASSERT_FALSE(checkString("", *r,res));
	delete r;
	ASSERT_NO_THROW(r = new Regular_expression("(<a>a)?"));
	ASSERT_TRUE(checkString("a", *r, res));
	ASSERT_STREQ("a", res.namedGroups.value()[0]["a"].c_str());
	ASSERT_TRUE(checkString("", *r, res));
	ASSERT_FALSE(checkString("<a>a", *r, res));
	delete r;
	ASSERT_NO_THROW(r = new Regular_expression("a(<a>b)"));
	ASSERT_TRUE(checkString("ab", *r, res));
	ASSERT_STREQ("b", res.namedGroups.value()[0]["a"].c_str());
	ASSERT_FALSE(checkString("a", *r));
	delete r;
	ASSERT_NO_THROW(r = new Regular_expression("(<a>b)a"));
	ASSERT_TRUE(checkString("ba", *r, res));
	ASSERT_STREQ("b", res.namedGroups.value()[0]["a"].c_str());
	ASSERT_FALSE(checkString("a", *r));
	delete r;
	ASSERT_NO_THROW(r = new Regular_expression("(<a>b|a)(<c>b|e)"));
	ASSERT_TRUE(checkString("bb", *r, res));
	ASSERT_STREQ("b", res.namedGroups.value()[0]["a"].c_str());
	ASSERT_STREQ("b", res.namedGroups.value()[0]["c"].c_str());
	ASSERT_TRUE(checkString("ae", *r, res));
	ASSERT_STREQ("a", res.namedGroups.value()[0]["a"].c_str());
	ASSERT_STREQ("e", res.namedGroups.value()[0]["c"].c_str());
	delete r;
	ASSERT_NO_THROW(r = new Regular_expression("(<a>b|(<c>e))"));
	ASSERT_TRUE(checkString("b", *r, res));
	ASSERT_STREQ("b", res.namedGroups.value()[0]["a"].c_str());
	ASSERT_TRUE(checkString("e", *r, res));
	ASSERT_STREQ("e", res.namedGroups.value()[0]["a"].c_str());
	ASSERT_STREQ("e", res.namedGroups.value()[0]["c"].c_str());
	delete r;
	ASSERT_THROW(r = new Regular_expression("(<a>afa)(<a>asb)"), SintaxTree_Exception);
}
TEST(OperatorsTest, LinkCaptureGroup) {
	Regular_expression* r;
	ASSERT_NO_THROW(r = new Regular_expression("(<a>a)<a>"));
	RgxResult res;
	ASSERT_TRUE(checkString("aa", *r));
	ASSERT_FALSE(checkString("", *r, res));
	ASSERT_FALSE(checkString("<a>a", *r, res));
	delete r;
	ASSERT_NO_THROW(r = new Regular_expression("(<a>a|b)<a>"));
	ASSERT_TRUE(checkString("aa", *r));
	ASSERT_TRUE(checkString("bb", *r,res));
	ASSERT_FALSE(checkString("ab", *r, res));
	ASSERT_FALSE(checkString("ba", *r, res));
	ASSERT_FALSE(checkString("b", *r, res));
	ASSERT_FALSE(checkString("a", *r, res));
	delete r;
	ASSERT_NO_THROW(r = new Regular_expression("(<a>a|b)<a>?"));
	ASSERT_TRUE(checkString("aa", *r));
	ASSERT_TRUE(checkString("bb", *r, res));
	ASSERT_FALSE(checkString("ab", *r, res));
	ASSERT_FALSE(checkString("ba", *r, res));
	ASSERT_TRUE(checkString("b", *r, res));
	ASSERT_TRUE(checkString("a", *r, res));
	delete r;
	ASSERT_NO_THROW(r = new Regular_expression("(<a>b)a<a>"));
	ASSERT_TRUE(checkString("bab", *r));
	ASSERT_FALSE(checkString("ba", *r));
	delete r;
	ASSERT_NO_THROW(r = new Regular_expression("(<a>b)<a>a"));
	ASSERT_TRUE(checkString("bba", *r));
	ASSERT_FALSE(checkString("ba", *r));
	delete r;
	ASSERT_NO_THROW(r = new Regular_expression("(<a>b|a)(<c>b|e)<a><c>"));
	ASSERT_TRUE(checkString("bbbb", *r, res));
	ASSERT_TRUE(checkString("aeae", *r, res));
	ASSERT_FALSE(checkString("bb", *r));
	ASSERT_FALSE(checkString("ae", *r));
	delete r;
	ASSERT_NO_THROW(r = new Regular_expression("(<a>b|(<c>e|d)<c>)<a><c>"));
	ASSERT_TRUE(checkString("eeeee", *r, res));
	ASSERT_TRUE(checkString("ddddd", *r, res));
	ASSERT_FALSE(checkString("eedde", *r));
	delete r;
	r = new Regular_expression("<a>(<a>afa)");
	ASSERT_THROW(checkString("afaafa", *r, res), std::logic_error);
	delete r;
	ASSERT_THROW(r = new Regular_expression("(<a>afa<a>)"), SintaxTree_Exception);
	ASSERT_THROW(r = new Regular_expression("<a>"), SintaxTree_Exception);
}
TEST(LibFunctions, checkstring) {
	rgx::Regular_expression st("(<a>a|b(<d>c|d))");
	ASSERT_TRUE(rgx::checkString("a", st));
	ASSERT_TRUE(rgx::checkString("bc", st));
	ASSERT_FALSE(rgx::checkString("ba", st));
	ASSERT_FALSE(rgx::checkString("b", st));
	rgx::Regular_expression r4("((<a>a)|(<b>b))<a><b>");
	ASSERT_TRUE(rgx::checkString("bbb", r4));
	rgx::Regular_expression r5("(<name>.{2,8})@(<mail>(m|a|i|l|g){2,8})&.com #(<k>abr|<mail>)");
	ASSERT_TRUE(rgx::checkString("yan.gas@gmail.com #gmail", r5));
	ASSERT_TRUE(rgx::checkString("yan.gas@gmail.com #abr", r5));
	RgxResult res;
	rgx::Regular_expression r6("(<code>&+7|8)?(<number>9(0|1|2|3|4|5|6|7|8|9){9,9})");
	ASSERT_TRUE(checkString("+79377089100", r6, res));
	ASSERT_STREQ("+7", res.namedGroups.value()[0]["code"].c_str());
	ASSERT_STREQ("9377089100", res.namedGroups.value()[0]["number"].c_str());
	ASSERT_TRUE(checkString("89044367300", r6, res));
	ASSERT_STREQ("8", res.namedGroups.value()[0]["code"].c_str());
	ASSERT_STREQ("9044367300", res.namedGroups.value()[0]["number"].c_str());
	ASSERT_TRUE(checkString("9044367300", r6, res));
	ASSERT_STREQ("", res.namedGroups.value()[0]["code"].c_str());
	ASSERT_STREQ("9044367300", res.namedGroups.value()[0]["number"].c_str());
	ASSERT_FALSE(checkString("88044367300", r6, res));
	ASSERT_FALSE(checkString("98044367300", r6, res));
	ASSERT_FALSE(checkString("8904437300", r6, res));
	ASSERT_FALSE(checkString("8904437j00", r6, res));
}
TEST(LibFunctions, k_path) {
	rgx::Regular_expression st("(a|b(c|d))");
	auto str = st.restore_expression();
	ASSERT_TRUE(rgx::checkString("a", str));
	ASSERT_TRUE(rgx::checkString("bc", str));
	ASSERT_FALSE(rgx::checkString("ba", str));
	rgx::Regular_expression r4("(a|b)bb");
	str = r4.restore_expression();
	ASSERT_TRUE(rgx::checkString("bbb", str));
	ASSERT_TRUE(rgx::checkString("abb", str));
	ASSERT_FALSE(rgx::checkString("abbb", str));
	ASSERT_FALSE(rgx::checkString("bb", str));
	rgx::Regular_expression r5("(.{2,4})@");
	str = r5.restore_expression();
	ASSERT_TRUE(rgx::checkString("yang@", str));
	rgx::Regular_expression r6("(&+7|8)?(9(0|1|2|3|4|5|6|7|8|9){9,9})");
	ASSERT_TRUE(checkString("+79377089100", r6.restore_expression()));
	ASSERT_FALSE(checkString("88044367300", r6.restore_expression()));
	ASSERT_FALSE(checkString("98044367300", r6.restore_expression()));
	ASSERT_FALSE(checkString("8904437j00", r6.restore_expression()));
}
TEST(LibFunctions, Language_addittion) {
	rgx::Regular_expression r("mephi&&|@&.?ru+");
	rgx::Regular_expression r1(r.make_language_addition());
	ASSERT_TRUE(rgx::checkString("mephi&ru", r1));
	ASSERT_TRUE(rgx::checkString("mephru", r1));
	ASSERT_TRUE(rgx::checkString("mephi&.ru", r1));
	ASSERT_TRUE(rgx::checkString("mephi&ruuuu", r1));
	ASSERT_FALSE(rgx::checkString("mephi&", r1));
	ASSERT_FALSE(rgx::checkString("@.ruuu", r1));
	ASSERT_FALSE(rgx::checkString("@ruuu", r1));
	ASSERT_TRUE(rgx::checkString("@druuu", r1));
	rgx::Regular_expression r8(".+");
	rgx::Regular_expression r9(r8.make_language_addition());
	ASSERT_FALSE(rgx::checkString("rrrrb", r9));
	ASSERT_FALSE(rgx::checkString("r", r9));
	ASSERT_TRUE(rgx::checkString("", r9));
}
TEST(LibFunctions, Language_inversion) {
	rgx::Regular_expression r("mephi&&|@&.?ru+");
	rgx::Regular_expression r2(r.make_language_inversion());
	ASSERT_FALSE(rgx::checkString("mephi&ru", r2));
	ASSERT_FALSE(rgx::checkString("uuur.@ihpem", r2));
	ASSERT_FALSE(rgx::checkString("ur&ihpem", r2));
	ASSERT_TRUE(rgx::checkString("&ihpem", r2));
	rgx::Regular_expression r6("b&.?r{2,4}");
	rgx::Regular_expression r7(r6.make_language_inversion());
	ASSERT_TRUE(rgx::checkString("rr.b", r7));
	ASSERT_TRUE(rgx::checkString("rrrrb", r7));
	ASSERT_TRUE(rgx::checkString("rrrb", r7));
	rgx::Regular_expression r8("ab?cd|de",true);
	ASSERT_TRUE(rgx::checkString("ed", r8));
	ASSERT_TRUE(rgx::checkString("dcba", r8));
	ASSERT_FALSE(rgx::checkString("dea", r8));
}
TEST(LibFunctions, findall) {
	rgx::Regular_expression r3("(<a>(ac)|(bd))1?");
	auto c = rgx::findAll("sacbd1ac1f", r3, true);
	ASSERT_STREQ("ac", c.goodSubstr[0].c_str());
	ASSERT_STREQ("bd1", c.goodSubstr[1].c_str());
	ASSERT_STREQ("ac1", c.goodSubstr[2].c_str());
	ASSERT_STREQ("ac", c.namedGroups.value()[0]["a"].c_str());
	ASSERT_STREQ("bd",c.namedGroups.value()[1]["a"].c_str());
	ASSERT_STREQ("ac", c.namedGroups.value()[2]["a"].c_str());
	rgx::Regular_expression r4("(<a>(ac)|(bd))1?(<d><a>)");
	 c = rgx::findAll("acacbd1bdwfbbd", r4, true);
	ASSERT_STREQ("acac", c.goodSubstr[0].c_str());
	ASSERT_STREQ("bd1bd", c.goodSubstr[1].c_str());
	ASSERT_STREQ("ac", c.namedGroups.value()[0]["a"].c_str());
	ASSERT_STREQ("bd", c.namedGroups.value()[1]["a"].c_str());
	ASSERT_STREQ("ac", c.namedGroups.value()[0]["d"].c_str());
	ASSERT_STREQ("bd", c.namedGroups.value()[1]["d"].c_str());
}
int main(int argc, char** argv) {
	::testing::InitGoogleTest(&argc, argv);
	return RUN_ALL_TESTS();
}